int chooseBestDistance(int t, int k, List<int> ls){
  // твій код
  // якщо у списку Мері немає достатньої кількості міст - друк -1:
  if (ls.length < k){
    print (-1);
  } 
  else{
    //міст достатньо, сортую список Мері:
    ls.sort();
    //рекурсивна функція яка рахує суму k елементів у сортованому списку Мері
    //з кожним викликом переміщається на 1 елемент до початку списку, 
    //аж до значення найближчого-меншого чи рівного t
    //як аргумент, отримує індекс в списку від якого рахувати суму k елементів в ліво:
    int findBest (n){
      var currentList = ls.sublist(n - k + 1, n + 1);
      var curentSum = currentList.fold(0, (p, c) => p + c);
      if (curentSum > t){
        //поточна сума завелика, функція викликає сама себе 
        //передаючи собі як аргумент індекс з списку із зсувом на 1 елемент в ліво:
        findBest (n - 1);   
      }
      else{
        //менша (найближча до завеликої) або рівна t сума знайдена 
        print (curentSum);
      }
      return 0;
    }
    //перший виклик функції з аргументом: останній (найбільший) елемент списку
    findBest (ls.length - 1);
  } 
  return 0;
}

void main(){
  chooseBestDistance(174, 3, [51, 56, 58, 59, 61]); //173
  chooseBestDistance(163, 3, [50]); // -1
  //chooseBestDistance(200, 4, [49, 56, 58, 59, 61, 36, 98]); //199
}
